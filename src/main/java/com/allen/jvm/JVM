1.JVM 
	1.Java内存模型、Java内存管理，Java堆和栈，垃圾回收机制
		1.1什么是内存模型
		 在多核系统中，处理器一般有一层或者多层的缓存，这些缓存通过加速数据访问(因为数据距离处理器更进)和降低共享内存在总线上的通讯(因为本地缓存能够满足许多内存操作)来提高CPU性能。
		 缓存能够大大的提高性能。但是，当俩个cpu同时检查相同的内存地址时会发生什么？在什么样的条件下他们会看到相同的值?
		 在处理器层面上，内存模型定义了一个充要条件，"让当前的处理器可以看到其他处理器写入到内存的数据"以及"其他处理器可以看到当前处理器写入到内存的数据"。
		 有些处理器有很强的内存模型(strong memory model),能够让所有的处理器在任何时候任何指定的内存地址上都可以看到完全相同的值。
		 而另一些处理器则又较弱的内存模型(weaker memory model),在这种处理器中，必须使用内存屏障(一种特殊的指定)来刷新本地处理器缓存并使本地处理器缓存无效，目的是为了让当前处理器能够看到
		 其他处理器的写操作或者让其他处理能够看到当前处理器的写操作。这些内存屏障通常在lock和unlock操作的时候完成。内存屏障在高级语言中对程序员来说是不可见的、
		 
		 在强内存模型下，有时候编程可能更加容易，因为减少了对内存屏障的依赖。但是即使在一些最强的内存模型下，内存屏障任然是必须得。设置内存屏障通常和我直接不一致。
		 进来的处理器更加倾向于弱的内存模型，因为弱内存模型消弱了缓存一致性，所以在多处理器的平台和更大容量的内存下实现更好的可伸缩性。
		 Java语言级别的关键字：volatile final synchronized。目的是为了帮助程序员向编译器描述一个程序员的并发需求。Java内存模型定义了volatile和synchronize的行为。更重要的是保证了同步的Java程序在所有的处理器架构下都能正常运行的。
		1.2其他的语言，像C++,也有内存模型吗?
			在大部分其他的语言，像C和C++，都没有被设计成直接支持多线程。这些语言对于发生在编译器和处理器平台的架构的重拍序行为的保证机制会严重的依赖于程序使用的多线程库。编译器，以及代码运行的平台锁提供的保障。
		1.3JSR133是什么？
			JSR133的木系是创建一组正式语义，这些正式语义提供了volatile synchronized final如何工作的直观框架
			保留已经存在的安全保证以及强化其他的安全保证。例如：变量值不能凭空创建：线程观察到的每个变量的值必须是被其他线程合理的设置的
			正确同步的程序语义应该尽量简单和直观
			应该定义为完成或者未正确同步的程序的语义，主要是为了把潜在的安全危害降到最低
			程序员应该能够自信的推断多线程程序如何同内存进行交互
			能够在线程许多流行的硬件架构中设计正确以及高性能的JVM实现
			应该能提供安全地初始化的保证。如果一个对象正确的构建（它的引用没有在构建的时候逸出）那么所有能够看到这个对象的引用的线程，在不进行同步的情况下，也将能看到在构造方法中设置final设置字段的值
			应该尽量不影响现有的代码
		1.4 重拍序意味着什么?
			在很多情况下，访问一个程序变量(对象实例字段，类静态字段和数组元素)可能会使用不同的顺序执行，而不是程序语义锁指定的顺序执行。编译器能够自由的以优化的名义去改变指令顺序。在特定的环境下，处理器可能会次序颠倒的执行指令。数据可能在寄存器，处理器缓冲区和主内存中以不同的次序移动，而不是按照
			程序指定的顺序。
			Exp：如果一个线程写入值到字段a 然后写入值到字段b 而且b的值不依赖于a的值，那么，处理器就能够只有的调整他们的执行顺序，而且缓冲区能够在a之前刷新b的值到主内存。有许多潜在的重排序的来源。
			例如编译器，JIT以及缓冲区
			编译器，运行时和硬件被期望一起协议创建好像是顺序执行的语义的假象，这意味着在单线程的程序中，程序应该是不能够观察到重排序的影响的但是，重排序子啊没有正确同步了得多线程程序中开始起作用，在这些多线程程序中，一个线程能够观察到其他线程的影响，也可能检测到其他线程将会以一种不同于程序语义锁规定的执行的顺序来访问变量。
	    1.5 旧的内存模型有什么问题?
	    	旧的内存模型中有几个严重的问题。
	    	如果使用final字段，那么就没有必要在多线程中使用同步来保证其他线程能够看到这个字段的值。但是，实际上，在旧的内存模型中，final字段并没有同其他字段进行区别对待，及同步是保证所有线程看到同一个在构造方法中初始化的final字段的唯一方法。
	    	如果没有正确同步的话，对于一个线程来说，它可能看到一个字段的默认值，然后在稍后的时间里，又能够看到构造方法中设置的值。这意味着，一些不可变的对象，例如String，能够改变他们的值。
	    	旧的内粗模型允许volatile变量的写操作和非volaitle变量的读写操作一起进行重排序，这和大多数的开发人员对于volatile变量的直观感受是不一致的。。
		1.6 没有正确同步的含义是什么？
			没有正确同步的代码对于不同的人来说可能会有不同的理解。在Java内存模型这个语义环境下。『没有正确同步』，意思是：
				一个线程中有一个对变量的写操作
				另一个线程对同一个变量有读操作
				而且写操作和读操作没有通过同步来保证顺序
			当这些规则被违反的时候，我们就说这个变量上又一个『数据竞争』(data race).一个有数据竞争的程序就是一个没有正确同步的程序、
		1.7 同步会干些什么?	
			同步几个方面的作用。
			 互斥:一次只有一个线程能够火的一个监听器，因此，在一个监听器上同步意味着一旦一线程进入到监听器保护的同步块中，其他的线程都不能进入到同一个监听器保护的块中间，除非第一个线程退出了同步块
	
			新的内存模型语义的内存操作(读写字段，写入字段，锁，解锁)以及其他线程的操作(start和join)中创建了一个部分排序，在这些操作中，一些操作被称为happen before其他操作。当一个操作在另外操作之前发生，第一个操作保证能够保证够排序到前面并且对第二个操作可见，排序的规则：
				线程中的每个操作 happen before该线程中在程序顺序上后续的每个操作
				解锁一个监听器的操作 happen before 随后对相同监听器进行锁的操作
				对volatile字段的写操作happens before 后续对相同volatile字段的读取操作。
				线程上调用start()方法happens before这个线程启动后的任何操作
				一个线程中所有的操作都happens before从这个线程join()方法成功返回的任何其他线程。
			任何内存操作，这个内存操作在退出一个通过不块前对一个线程是可见的，对任何线程在它进入一个被相同的监听器保护的同步快都是可见的，因为所有内存操作happens before释放监听器以及解释监听器happens before获取监听器
			对于俩个线程来说，为了正确建立happens before关系而在相同监听器上面进行同步是非常重要的。以下观点是错误的：当线程A在对象X上面同步的时候，所有东西对线程A可见，线程B在对象Y上面进行同步的时候，所有东西对线程B也是可见的。释放监听器和获取监听器必须匹配。否则，代码就会存在数据竞争。
		1.8 为什么关注Java内存模型
			在并发程序中的BUG非常难找。他们将从不会在程序中发生，而是直到你在程序运行在高负荷的情况下才发生，非常难于重现和跟踪。你需要花费更多的努力提前保证的你的程序是同步的。
	
	
	2.JVM各种参数以及调优
		
	
	
	
	
	3.Java工具{jps jstack jmap jconsole jinfo jhat javap等}
		1.javap (详细请看com.allen.orign.MainTest.java)
		  -version 
		  -v verbose    输出附加信息
		  -l			输出行号和本地变量表
	 	  -public		仅显示公共类和成员
		  -protected	显示受保护的/公共类和成员
		  -package		显示程序包/受保护的/公共类和成员
		  -c			对代码进行反汇编
		  -s			输出内部类签名
		  -sysinfo		显示正在处理的类的
		  -constants    显示静态最终常量
		  -classpath	指定查找用户类文件的位置
	4.Java诊断工具
	
	
	5.各种outOfMemory stackoverflow程序